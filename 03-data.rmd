# Data handling {#data-handling}


![](media/ropes.png)

```{r include=F}
library(tidyverse)
library(webex)
```

### In brief

> Most time in data analysis is spent 'tidying up' data: getting it into a suitable format to get
> started. Data scientists have a particular definition of _tidy_: Tidy datasets are "easy to
> manipulate, model and visualize, and have a specific structure: each variable is a column, each
> observation is a row" [@wickham_tidy_2014].

> It's often not convenient for humans to _enter_ data in a tidy way, so untidy data is probably
> more common than tidy data in the wild. But doing good, reproducible science demands that we
> document each step of our processing in a way that others can check or repeat in future. Tools
> like R make this easier.

## Overview

So far we have used various commands in the `tidyverse` to work with several datasets. If you want
to recap these commands you can use the ['cheatsheet' here](#cheatsheet) especially
[this section](#dplyr-cheat) and the part on [groups and summaries](#cheat-group-summary).

Today we will cover two additional techniques which are important when working with real datasets:

-   Creating new variables/columns
-   Reshaping or reformatting data from long to wide (or vice versa)
-   Joining two sources of data (e.g. two spreadsheets) into a single dataframe

---

In the second part of the session we will cover RMarkdown, which is an alternative to R script files
which lets us combine text, graphics and R code and is useful when sharing our work.

## Making new variables

Sometimes we need to create new columns in our dataset. For example, let's say we wanted to
calculate someone's BMI from their weight and height.

There is a built in dataset called `women`, which contains heights and weights of 15 women in lbs
and inches:

```{r}
women  %>% glimpse
```

To calculate a BMI we first need to convert the heights to from inches to meters, and the weights
from lbs to kilograms.

```{r}
metric_women <- women  %>%
  mutate(
    height_m = height*0.0254,  # approx conversion from inches to m
    weight_kg= weight*0.45     # conversion from lbs to kg
  )
```

**Explanation**: We used mutate to covert lbs to kg and inches to m, and saved these two new columns
in the `metric_women` dataset.

We can see the new columns here:

```{r}
metric_women %>% head(3)
```

BMI is calculated as $kg / m^2$. We can use mutate again for this:

```{r}
metric_women  %>%
  mutate(BMI = weight_kg / height_m^2) %>%
  head(3)
```

**Explanation**: We used mutate again to make a new column, `BMI`. This contains womens' weight
divided by their squared height (`^2` means _to the power of 2_ in R-speak).

:::{.exercise}

-   Create a density plot of BMI scores in the `women` dataset. It should look like this:

```{r, echo=F}
bmis <- metric_women %>% mutate(BMI = weight_kg / height_m^2)
bmis %>%
 ggplot(aes(BMI)) +
 geom_density()
```

-   What is the median BMI in the sample? `r fitb(answer=round(median(bmis$BMI),1))`

:::

## Reshaping (melting)

Data is commonly stored in either
[_wide_ or _long_ format](https://www.theanalysisfactor.com/wide-and-long-data/).

If you used SPSS to do a _t_-test or ANOVA during your undergraduate degree, you likely analysed the
data in **wide** format. In wide format, each row represents the _observations from a single
participant_. Each measurement for a given participant are stored in separate columns.

This is often called **row per subject** data. An example is the built in `attitude` dataset:

```{r}
attitude %>%
  head()
```

**Explanation**: Each row contains scores for a particular employee on various measures. To find out
more about these data you can type `?attitude` into the console.

---

Let's say we want a single plot of all these variables, something like this:

```{r echo=F, message=F, warning=F}
library(data.table)
attitude %>%
  as.data.table() %>%
  melt() %>%
  mutate(variable=Hmisc::capitalize(as.character(variable))) %>%
  ggplot(aes(variable, value)) +
  geom_boxplot() +
  labs(x="Measure", y="Score")
```

To do this we first need to convert the data to _long_ format. In **long format**, each observation
is saved in its own row, rather than across multiple columns.

It's often called **"row per observation"** data.

---

We can convert from wide to long using the `melt` command in the `data.table` package. First we need
to load the `data.table` package:

```{r}
library(data.table)
```

![img: [TrueWarrior](https://www.reddit.com/r/gifs/comments/ppam4/ice_cream_melting_and_remelting/)](https://i.imgur.com/UBGhu.gif)

To see why the command is called 'melt', imagine taking three columns of data fo the first two rows:

```{r  message=F, warning=F}
attitude %>%
  select(rating, complaints, privileges) %>%
  head(2)
```

If we use `melt` on this selection, we end up with this:

```{r message=F, warning=F}
attitude %>%
  select(rating, complaints, privileges) %>%
  head(2) %>%
  melt()
```

The change works like like this:

![Converting from wide format to long format](media/data_wide2Long_attitude.jpg)

In this example we don't have an explicit record of which participant was which in the `attitude`
dataset, because the mapping to participants was implicit: each row was a new participant, but they
were not marked.

We can make this explicit by adding a new column to the data with the `mutate` command:

```{r}
attitude %>%
  select(rating, complaints, privileges) %>%
  mutate(person = row_number()) %>%
  head(2)
```

And now, if we repeat the melt, we can specify `id.var="person"`. This tells R which column
identifies the rows:

```{r}
attitude %>%
  select(rating, complaints, privileges) %>%
  mutate(person = row_number()) %>%
  head(2) %>%
  melt(id.var="person")
```

:::{.exercise}

Use the tidyverse commands you know plus `melt` to produce this plot:

```{r echo=F, message=F, warning=F}
attitude %>%
  select(rating, complaints, learning) %>%
  data.table::melt() %>%
  mutate(variable=Hmisc::capitalize(as.character(variable))) %>%
  ggplot(aes(variable, value)) +
  geom_boxplot() +
  labs(x="Measure", y="Score")

```

:::

:::{.exercise}

For an extension (and only if you have plenty of time), use the `mtcars` data and facetting to
produce these plots:

```{r, echo=F, message=F, warning=F}
mtcars %>%
  select(mpg, wt, disp) %>%
  melt() %>%
  mutate(variable=Hmisc::capitalize(as.character(variable))) %>%
  ggplot(aes(value, y=..scaled..)) +
  geom_density() +
  facet_wrap(~variable, scales="free_x") +
  labs(x="", y="Scaled density")
```

```{r, echo=F}
mtcars %>%
  select(mpg, wt, disp) %>%
  melt() %>%
  mutate(variable=Hmisc::capitalize(as.character(variable))) %>%
  ggplot(aes(value)) +
  geom_histogram(bins=7) +
  facet_wrap(~variable, scales="free_x") +
  labs(x="", y="Scaled density")
```

As a tip, you will need to:

-   add `scales="free_x"` to the `facet_wrap` function. So, it will read:
    `facet_wrap(~VARNAME, scales="free_x")`
-   for the histogram, replace `geom_density()` with `geom_histogram()`
-   adjust the number of vertical bars in the histogram by adding `bins=7` (or some other number) to
    `geom_histogram()`

:::

### Using melt to make summaries

Imagine we want a table of the mean score on each question in the attitude dataset. This would be
fiddly if we just tried to use summarise before reshaping, but if we use `melt`, `group_by` and then
`summarise` (in that order) it is easy to make a table like this:

```{r, echo=F, message=F}
attitude %>%
  melt() %>%
  group_by(variable) %>%
  summarise(mean = mean(value), sd=sd(value)) %>%
  mutate_if(is.numeric, ~round(.,2)) %>%
  pander::pander()
```

:::{.exercise}

Use the `melt`, `group_by` and `summarise` commands (in that order) to reproduce the table above.

:::

## Reshaping wide (casting)

Sometimes we have the opposite problem: We have long data, but want it in wide format. For example,
we might want a table where it's easy to compare between different years, like this:

```{r, echo=F, message=F}
gapminder::gapminder %>%
  select(country, continent, year, gdpPercap) %>%
  filter(year > 1996 & continent=="Europe") %>%
  data.table::dcast(country~year) %>%
  head() %>% pander::pander("GDP per-capita in 3 different years from the gaminder dataset.")
```

---

To do this `data.table` has a command called `dcast`. The metaphor here is _casting_ a fishing line
or net --- that is, turning something that was long/vertical into something wide/horizontal.

![Hopefully not quite like this. Image source: [gifbin](gifbin.com)](media/throwing_fish_net_fail.gif)

---

First make sure the package is loaded:

```{r, eval=F}
library(data.table)
```

As we saw before the `gapminder` data is a fairly long format. There are multiple rows per-country
corresponding to different years.

To cast `gapminder` to a wide format to _compare_ years we first need to select the data we want ---
country, year and GDP:

```{r, message=F, warning=F}
gapminder1990s <- gapminder::gapminder %>%
  select(country, year, gdpPercap) %>%
  filter(year > 1990)
```

Then we add the `dcast` command:

```{r}
gapminder1990s %>%
  dcast(country~year) %>%
  head()
```

**Explanation of the output**: We started with multiple rows per country, corresponding to years. We
used `dcast(country~year)` to cast the data into wide format. The result has countries listed
one-per-row; data for each year are shown in a separate column. This helps us compare years within
countries.

**Explanation of the command**: The `country~year` part tells dcast to create a table where
countries make up the rows, and years make up the columns. That is the variables to the left of the
`~` symbol will define the rows in the table, and the variables to the right of the `~` will create
new columns.

:::{.tip}

The squiggly `~` symbol is called a tilde (say "tilder").

-   On a Mac it's the key to the left of the `Z` (you need to press `shift` to type it).

-   On a PC it's normally between the `@` symbol and the `Enter` key.

:::

We can add multiple variables to the left or right of the `~` to create different shape tables.

For example:

```{r, message=F, warning=F}
gapminder::gapminder %>%
  select(continent, country, year, gdpPercap) %>%
  filter(year > 1990) %>%
  dcast(continent + country ~ year) %>%
  head()
```

:::{.exercise}

Experiment for yourself with `dcast`:

-   What happens if we write `dcast(year ~ country)` instead of `dcast(country ~ year)`?
-   Use more than one variable on the left or right of the `~`
-   Experiment with some different datasets

As an extension:

-   Think about how you might use `dcast` with the `group_by` and `summarise` approach we used
    above. Can you create an example where using these techniques together produces a useful table?

:::

## RMarkdown

Markdown is a simple **text format** which can include writing, tables and images (see
http://commonmark.org/help/).

An RMarkdown document mixes R code with Markdown. You can generate images (plots) and tables
directly using R code.

In the language of RStudio, you **'knit'** your RMarkdown document to produce a finished document.
Knitting:

1. runs your code and
2. combines the analyses, graphs, with your explanatory text to
3. make a single pdf or html file.

This knitted file documents your work and can be shared easily with others.

#### Why use Rmarkdown?

Rmarkdown is becoming an important tool in the open science movement. Authors often share details of
their analysis in an Rmarkdown file because journal articles are too constrained to document this
properly.

A recent example from Plymouth is shared here: <https://zenodo.org/record/1120364>. This repository
includes:

-   The datafile in CSV format
-   The Rmarkdown source file
-   The knitted html document
    ([click here to have a look](media/whalley-andrade-data_supplement.html))

The [main assessment for this module](#assessment-authentic-analysis) requires you to make an Rmd
file like this to share a re-analysis of a published paper, so learning how to use Rmd is an
important part of the course.

### Creating a fresh RMarkdown file

The easiest way to create and RMarkdown file is from the `File > New > RMarkdown` menu option:

![](media/newrmd.png)

It should look something like this when you've done it:

![A new Rmd file, from the RStudio template.](media/new_rmd_file.png)

**Explanation** We asked RStudio to create a new Rmd file. Rstudio makes the new file from a
template, and this shows off some of the main features of RMarkdown.

---

RMarkdown files have the file extensions `.rmd` and must to be saved before they can be 'knitted'.

:::{.exercise}

1. Create a new Rmd file and save it somewhere in your home directory on the Rstudio server (or the
   same place you saved your other R Script files).

1. Have a look through the example file created in RStudio. Have a guess at what each part does.

1. Press the 'knit' button in the RStudio interface and check the results.

:::

### Working with 'chunks' of R code

To include R code within RMarkdown we write 3 backticks followed by `{r}`.

We then write some R code, and close the chunk with 3 more backticks. This is what it looks like:

![A code chunk in the RMarkdown editor](media/r-code-chunk.png)

`r hide("Can't find the backtick on your keyboard?")`

![On windows](media/backtick-windows-uk.png)

![On a Mac](media/backtick-mac-uk.png)

`r unhide()`

:::{.exercise}

As you do this exercise, take care to get the right number of backticks, and your curly brackets
(`{}`) in the right place.

1. Create a new 'chunk' of R code which includes one of the plots you have made so far today. Use
   one of the built in datasets for now.

1. Make sure you add `library(tidyverse)` just above your plot code.

1. Press 'knit' again and check the result.

:::

:::{.tip}

If you are getting errors when adding a code chunk always check you have:

-   3 backticks, then `{r}`, then **start a new line**
-   Your R code comes next
-   Load any packages needed at the top of the first chunk.
-   3 more backticks, **on their own line**. These final 3 backticks **must** start at the beginning
    of the line, have no spaces in front of them, and nothing after them.

If you are still getting errors:

-   Read the error message - it can give a clue
-   Simplify everything (remove R code until it works, then try again)

Using libraries in chunks:

-   Load packages (e.g. `library(tidyverse)`) once at the top of the file.
-   Remember that RStudio knits code from top to bottom (so load packages **before** you use them)
-   R wipes it's memory each time it knits your file, so needs reminding. You only need to load the
    package in one chunk though (don't do it multiple times).

:::

### Working interactively with Rmarkdown

Rather than typing commands in the console, **you should now run code directly from your Rmd code
chunks**.

This makes it much easier to keep track of your work.

See this video for an example:

<iframe src="https://player.vimeo.com/video/225968925" width="640" height="400" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen></iframe>

:::{.exercise}

1. Put your cursor (pointer) anywhere inside the new chunk you added, containing the R code for your
   plot. The chunk should look something like this:

![](media/rchunk2.png)

2.  Press the green 'run' button (a rightward pointing triangle) in the top right corner of the
    chunk. Where does the result appear?

3.  Change the R code in your chunk (e.g. make a different plot). Press 'run' again.

4) Write several lines of R code in your chunk. Put the cursor on one of the lines and press
   `ctrl+enter` or `cmd+enter` if you are on a mac. Does this run all of the code in the chunk, or
   just part of it?

5. Write some code which uses `summarise` inside your code chunk to produce a table

:::


## Final task (to be completed as homework)

:::{.exercise}

Work in your previous groupings.

Use Rmarkdown to present your findings from the Berkley admissions data we covered in the past session. It should:

- Load the data and packages needed
- Use section headings (i.e. use the `#` or `##` to create a 1st or 2nd level heading)
- Include 2 or 3 plots
- Include text describing your conclusions  on the main question (was the admissions system 'fair')

When you are finished, knit the Rmd document to produce an html or PDF output (it's actually a good idea to knit regularly to pick up any errors).

:::



## Extension exercises and reading

-   Read this article on wide/long data formats and the tradeoffs between the two:
    https://www.theanalysisfactor.com/wide-and-long-data/

### Making nicer tables in RMarkdown

The `pander` function in the `pander` library can help make nicer tables when using RMarkdown.

For example, if we take a few rows from the Iris data they look like this:

```{r}
iris %>% head
```

But if we load the `pander` package, and use the `pander` command we get a nice table, like this:

```{r}
library(pander)
iris %>% head %>% pander
```

And we can add a caption to the table like this:

```{r}
iris %>% head %>% pander(caption="The first 6 rows from the iris dataset")
```

:::{.exercise}

Revisit one of the tasks that used [`group_by` + `summarise`](#cheat-group-summary). Use pander to
display the table in a nicer format, and knit your Rmarkdown file to pdf/html to see the results.

:::

### Separating 'untidy' variables into tidy, long-form data:

The code below generates simulated data for 100 individuals at three time points. The format is
similar to the way you might record experimental data in a spreadsheet.

```{r}
N <- 20
repeatmeasuresdata <- tibble(person = 1:N,
  time_1 = rnorm(N),
  time_2 = rnorm(N, 1),
  time_3 = rnorm(N, 3))

repeatmeasuresdata %>% head
```

`repeatmeasuresdata` is in **wide** format. Each row contains data for one participant, and each
participant has three observations.

We can melt the data into long format like so:

```{r}
repeatmeasuresdata %>%
  melt(id.var = "person") %>%
  arrange(person, variable) %>%
  head(7)
```

The problem we have now is that `variable` contains text which describes at which time the
observation was made. We probably want a number for each timepoint, so we can make a plot with time
on the x axis.

The `separate` command separates a single character column (`variable`) into multiple columns.
Rather than have a column with labels of the form 'time_1', it can create two columns, with labels
'time' and '1' in each.

```{r}
longrepeatmeasuresdata <- repeatmeasuresdata %>%
  melt(id.var = "person") %>%
  separate(variable, into = c("_", "time"))

longrepeatmeasuresdata %>% head
```

Now the data are in long format, we can plot the points over time:

```{r}
longrepeatmeasuresdata %>%
  sample_n(30) %>%
  ggplot(aes(x=time, y=value)) +
  geom_point()
```
